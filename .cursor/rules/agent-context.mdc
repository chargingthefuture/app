---
alwaysApply: true
---

# Context Prompt for Cursor AI - Psyop-Free Ecosystem

## 🎯 Application Overview

This is a **secure, invite-only platform** for survivors of human trafficking, built as a **WeChat-style super app** where each service operates as an independent mini-app sharing core platform functionalities.

**Key Values:** Safety, privacy, dignity, accessibility (WCAG AAA), trauma-informed design

**Tech Stack:**
- Frontend: React + TypeScript + Vite + Wouter (routing) + TanStack Query (state) + shadcn/ui + Tailwind
- Backend: Express.js + TypeScript + Replit Auth (OIDC) + PostgreSQL (Neon) + Drizzle ORM
- Architecture: Monorepo with shared types between frontend/backend

---

## 🏗️ Critical Architecture Patterns

### 1. **Mini-App (Super App) Architecture**

Each service (SupportMatch, SleepStories, LightHouse, SocketRelay, Directory, ChatGroups) is a **self-contained mini-app** with its own:
- Database tables in `shared/schema.ts`
- Storage methods in `server/storage.ts`
- API routes in `server/routes.ts`
- Frontend pages in `client/src/pages/{mini-app-name}/`
- Sidebar navigation entry in `client/src/components/app-sidebar.tsx`

**🚨 CRITICAL:** Never mix concerns between mini-apps. Each operates independently.

---

## 📂 File Structure & Responsibilities

```
project-root/
├── shared/
│   └── schema.ts          ← ALL database tables, types, Zod schemas
├── server/
│   ├── storage.ts         ← Data access layer (repository pattern)
│   ├── routes.ts          ← ALL API endpoints
│   ├── replitAuth.ts      ← Auth middleware (isAuthenticated, isAdmin)
│   └── index.ts           ← Express setup (DON'T modify)
├── client/src/
│   ├── App.tsx            ← Main router & layout (SidebarProvider here)
│   ├── components/
│   │   ├── app-sidebar.tsx  ← Navigation menu (add new routes here)
│   │   └── ui/            ← shadcn components (reusable)
│   ├── pages/
│   │   ├── home.tsx       ← User dashboard
│   │   ├── admin/         ← Platform-wide admin pages
│   │   └── {mini-app}/    ← Mini-app specific pages
│   ├── hooks/
│   │   └── useAuth.ts     ← Auth hook (user, isAdmin, loading)
│   └── lib/
│       └── queryClient.ts ← TanStack Query setup
├── scripts/                ← App seeders and utility scripts (seed per mini-app)
└── design_guidelines.md   ← Design system (READ THIS!)
```

---

## 🔧 How to Add a New Feature

### **A. Adding a New Mini-App**

**🚨 REQUIRED:** Every new mini-app MUST have:
1. **User profile** - Every mini-app requires a user profile with edit and delete functionality
2. **User-facing pages** - Where regular users interact with the app
3. **Admin page** - A dedicated admin interface under the Administration section for managing the app's content/data
4. **Announcement system** - Every mini-app must have its own announcement table and admin interface for managing announcements specific to that app

Follow this exact sequence:

#### **Step 1: Database Schema (`shared/schema.ts`)**

**🚨 REQUIRED:** Every mini-app MUST have a profile table. Add tables at the bottom, following this pattern:

```typescript
// ========================================
// {MINI_APP_NAME} APP TABLES
// ========================================

export const myAppProfiles = pgTable("my_app_profiles", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().unique().references(() => users.id),
  // ... mini-app specific fields
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Define relations
export const myAppProfilesRelations = relations(myAppProfiles, ({ one }) => ({
  user: one(users, {
    fields: [myAppProfiles.userId],
    references: [users.id],
  }),
}));

// Create insert schema (for validation)
export const insertMyAppProfileSchema = createInsertSchema(myAppProfiles).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Export types
export type InsertMyAppProfile = z.infer<typeof insertMyAppProfileSchema>;
export type MyAppProfile = typeof myAppProfiles.$inferSelect;

// MyApp Announcements
export const myappAnnouncements = pgTable("myapp_announcements", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  title: varchar("title", { length: 200 }).notNull(),
  content: text("content").notNull(),
  type: varchar("type", { length: 50 }).notNull().default('info'), // info, warning, maintenance, update, promotion
  isActive: boolean("is_active").notNull().default(true),
  expiresAt: timestamp("expires_at"),
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

export const insertMyappAnnouncementSchema = createInsertSchema(myappAnnouncements).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
}).extend({
  expiresAt: z.coerce.date().optional().nullable(),
});

export type InsertMyappAnnouncement = z.infer<typeof insertMyappAnnouncementSchema>;
export type MyappAnnouncement = typeof myappAnnouncements.$inferSelect;
```

**🚨 IMPORTANT:** Always use `varchar("id").primaryKey().default(sql\`gen_random_uuid()\`)` for IDs to match existing pattern.

#### **Step 2: Storage Interface (`server/storage.ts`)**

1. Import your new tables/types at the top
2. Add methods to `IStorage` interface (around line 74):
```typescript
export interface IStorage {
  // ... existing methods
  
  // MyApp Profile operations
  getMyAppProfile(userId: string): Promise<MyAppProfile | undefined>;
  createMyAppProfile(profile: InsertMyAppProfile): Promise<MyAppProfile>;
  updateMyAppProfile(userId: string, profile: Partial<InsertMyAppProfile>): Promise<MyAppProfile>;
  
  // Profile deletion with cascade anonymization
  deleteMyAppProfile(userId: string, reason?: string): Promise<void>;
  
  // MyApp Announcement operations
  createMyappAnnouncement(announcement: InsertMyappAnnouncement): Promise<MyappAnnouncement>;
  getActiveMyappAnnouncements(): Promise<MyappAnnouncement[]>;
  getAllMyappAnnouncements(): Promise<MyappAnnouncement[]>;
  updateMyappAnnouncement(id: string, announcement: Partial<InsertMyappAnnouncement>): Promise<MyappAnnouncement>;
  deactivateMyappAnnouncement(id: string): Promise<MyappAnnouncement>;
}
```

**🚨 REQUIRED:** Profile deletion method must:
- Accept `userId` (not profile id) and optional `reason`
- Anonymize related data by replacing user IDs with `deleted_user_[random_string]`
- Log the deletion using `logProfileDeletion()` 
- Delete the profile itself

3. Implement in `DatabaseStorage` class (around line 200+):
```typescript
class DatabaseStorage implements IStorage {
  // ... existing methods
  
  async getMyAppProfile(userId: string): Promise<MyAppProfile | undefined> {
    const [profile] = await db
      .select()
      .from(myAppProfiles)
      .where(eq(myAppProfiles.userId, userId));
    return profile;
  }
  
  async createMyAppProfile(profile: InsertMyAppProfile): Promise<MyAppProfile> {
    const [created] = await db
      .insert(myAppProfiles)
      .values(profile)
      .returning();
    return created;
  }
  
  async updateMyAppProfile(userId: string, profile: Partial<InsertMyAppProfile>): Promise<MyAppProfile> {
    const [updated] = await db
      .update(myAppProfiles)
      .set({ ...profile, updatedAt: new Date() })
      .where(eq(myAppProfiles.userId, userId))
      .returning();
    return updated;
  }
  
  async deleteMyAppProfile(userId: string, reason?: string): Promise<void> {
    const profile = await this.getMyAppProfile(userId);
    if (!profile) {
      throw new Error("MyApp profile not found");
    }
    
    const anonymizedUserId = this.generateAnonymizedUserId();
    
    // Anonymize related data (e.g., messages, requests, etc. that reference this user)
    // Example: await db.update(relatedTable).set({ userId: anonymizedUserId }).where(eq(relatedTable.userId, userId));
    
    // Delete the profile
    await db.delete(myAppProfiles).where(eq(myAppProfiles.userId, userId));
    
    // Log the deletion
    await this.logProfileDeletion(userId, "myapp", reason);
  }
  
  // Helper method (already exists in class)
  private generateAnonymizedUserId(): string {
    const randomString = randomBytes(16).toString('hex');
    return `deleted_user_${randomString}`;
  }
}
```

#### **Step 3: API Routes (`server/routes.ts`)**

1. Import schemas at top:
```typescript
import { insertMyAppProfileSchema } from "@shared/schema";
```

2. Add routes (group them together, around line 500+):
```typescript
// ========================================
// MyApp Routes
// ========================================

// MyApp Announcement routes (public)
app.get('/api/myapp/announcements', isAuthenticated, async (req, res) => {
  try {
    const announcements = await storage.getActiveMyappAnnouncements();
    res.json(announcements);
  } catch (error) {
    console.error("Error fetching MyApp announcements:", error);
    res.status(500).json({ message: "Failed to fetch announcements" });
  }
});

app.get('/api/myapp/profile', isAuthenticated, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const profile = await storage.getMyAppProfile(userId);
    res.json(profile);
  } catch (error: any) {
    console.error("Error fetching MyApp profile:", error);
    res.status(500).json({ message: error.message });
  }
});

app.post('/api/myapp/profile', isAuthenticated, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const validatedData = insertMyAppProfileSchema.parse(req.body);
    const profile = await storage.createMyAppProfile({
      ...validatedData,
      userId,
    });
    res.json(profile);
  } catch (error: any) {
    console.error("Error creating MyApp profile:", error);
    res.status(500).json({ message: error.message });
  }
});

app.put('/api/myapp/profile', isAuthenticated, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const profile = await storage.updateMyAppProfile(userId, req.body);
    res.json(profile);
  } catch (error: any) {
    console.error("Error updating MyApp profile:", error);
    res.status(400).json({ message: error.message || "Failed to update profile" });
  }
});

app.delete('/api/myapp/profile', isAuthenticated, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const { reason } = req.body;
    await storage.deleteMyAppProfile(userId, reason);
    res.json({ message: "MyApp profile deleted successfully" });
  } catch (error: any) {
    console.error("Error deleting MyApp profile:", error);
    res.status(400).json({ message: error.message || "Failed to delete profile" });
  }
});

// MyApp Admin Announcement routes
app.get('/api/myapp/admin/announcements', isAuthenticated, isAdmin, async (req, res) => {
  try {
    const announcements = await storage.getAllMyappAnnouncements();
    res.json(announcements);
  } catch (error) {
    console.error("Error fetching MyApp announcements:", error);
    res.status(500).json({ message: "Failed to fetch announcements" });
  }
});

app.post('/api/myapp/admin/announcements', isAuthenticated, isAdmin, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const validatedData = insertMyappAnnouncementSchema.parse(req.body);

    const announcement = await storage.createMyappAnnouncement(validatedData);
    
    await logAdminAction(
      userId,
      "create_myapp_announcement",
      "announcement",
      announcement.id,
      { title: announcement.title, type: announcement.type }
    );

    res.json(announcement);
  } catch (error: any) {
    console.error("Error creating MyApp announcement:", error);
    res.status(400).json({ message: error.message || "Failed to create announcement" });
  }
});

app.put('/api/myapp/admin/announcements/:id', isAuthenticated, isAdmin, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const announcement = await storage.updateMyappAnnouncement(req.params.id, req.body);
    
    await logAdminAction(
      userId,
      "update_myapp_announcement",
      "announcement",
      announcement.id,
      { title: announcement.title }
    );

    res.json(announcement);
  } catch (error: any) {
    console.error("Error updating MyApp announcement:", error);
    res.status(400).json({ message: error.message || "Failed to update announcement" });
  }
});

app.delete('/api/myapp/admin/announcements/:id', isAuthenticated, isAdmin, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const announcement = await storage.deactivateMyappAnnouncement(req.params.id);
    
    await logAdminAction(
      userId,
      "deactivate_myapp_announcement",
      "announcement",
      announcement.id,
      { title: announcement.title }
    );

    res.json(announcement);
  } catch (error: any) {
    console.error("Error deleting MyApp announcement:", error);
    res.status(400).json({ message: error.message || "Failed to delete announcement" });
  }
});
```

**🚨 Pattern:** Always validate with Zod schemas, use `getUserId(req)`, wrap in try/catch

#### **Step 4: Frontend Pages (`client/src/pages/myapp/`)**

**🚨 REQUIRED:** Every mini-app MUST have a profile page with Edit and Delete buttons.

Create folder: `client/src/pages/myapp/`

Example dashboard (`dashboard.tsx`):
```typescript
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/useAuth";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Link } from "wouter";

export default function MyAppDashboard() {
  const { user } = useAuth();
  
  const { data: profile, isLoading } = useQuery({
    queryKey: ['/api/myapp/profile'],
    enabled: !!user,
  });
  
  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div className="container mx-auto p-6 max-w-7xl">
      <h1 className="text-3xl font-semibold mb-6">MyApp Dashboard</h1>
      
      {/* 🚨 REQUIRED: Display active announcements at the top */}
      <AnnouncementBanner 
        apiEndpoint="/api/myapp/announcements"
        queryKey="/api/myapp/announcements"
      />
      <Card>
        <CardHeader>
          <CardTitle>Welcome to MyApp</CardTitle>
        </CardHeader>
        <CardContent>
          {profile ? (
            <Button asChild>
              <Link href="/apps/myapp/profile">Edit Profile</Link>
            </Button>
          ) : (
            <Button asChild>
              <Link href="/apps/myapp/profile">Create Profile</Link>
            </Button>
          )}
          {/* Your content */}
        </CardContent>
      </Card>
    </div>
  );
}
```

**🚨 REQUIRED Profile Page (`profile.tsx`):**

Every mini-app MUST have a profile page with:
- Edit profile form (create/update)
- **Delete Profile button** (only visible when profile exists)
- **Delete confirmation dialog** using `DeleteProfileDialog` component

Example profile page:
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Input } from "@/components/ui/input";
import { useToast } from "@/hooks/use-toast";
import { queryClient, apiRequest } from "@/lib/queryClient";
import { insertMyAppProfileSchema, type MyAppProfile } from "@shared/schema";
import { z } from "zod";
import { useState } from "react";
import { DeleteProfileDialog } from "@/components/delete-profile-dialog";
import { useLocation } from "wouter";

const profileFormSchema = insertMyAppProfileSchema.omit({ userId: true });
type ProfileFormData = z.infer<typeof profileFormSchema>;

export default function MyAppProfile() {
  const { toast } = useToast();
  const [, setLocation] = useLocation();
  const [deleteDialogOpen, setDeleteDialogOpen] = useState(false);
  
  const { data: profile, isLoading } = useQuery<MyAppProfile | null>({
    queryKey: ["/api/myapp/profile"],
  });

  const form = useForm<ProfileFormData>({
    resolver: zodResolver(profileFormSchema),
    defaultValues: {
      // ... default values
    },
  });

  const updateMutation = useMutation({
    mutationFn: (data: ProfileFormData) =>
      apiRequest("PUT", "/api/myapp/profile", data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/myapp/profile"] });
      toast({ title: "Profile Updated", description: "Your profile has been updated successfully." });
    },
  });

  const createMutation = useMutation({
    mutationFn: (data: ProfileFormData) =>
      apiRequest("POST", "/api/myapp/profile", data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/myapp/profile"] });
      toast({ title: "Profile Created", description: "Your profile has been created successfully." });
      setLocation("/apps/myapp");
    },
  });

  // 🚨 REQUIRED: Delete mutation with reason support
  const deleteMutation = useMutation({
    mutationFn: (reason?: string) =>
      apiRequest("DELETE", "/api/myapp/profile", { reason }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/myapp/profile"] });
      setDeleteDialogOpen(false);
      toast({ title: "Profile Deleted", description: "Your profile has been deleted successfully." });
      setLocation("/apps/myapp");
    },
    onError: (error: any) => {
      toast({ title: "Error", description: error.message || "Failed to delete profile", variant: "destructive" });
    },
  });

  const onSubmit = (data: ProfileFormData) => {
    if (profile) {
      updateMutation.mutate(data);
    } else {
      createMutation.mutate(data);
    }
  };

  if (isLoading) return <div>Loading...</div>;

  return (
    <div className="p-4 sm:p-6 md:p-8 space-y-6">
      <h1 className="text-2xl sm:text-3xl font-semibold mb-2">
        {profile ? "Edit Profile" : "Create Profile"}
      </h1>
      
      <Card>
        <CardHeader>
          <CardTitle>Profile Information</CardTitle>
        </CardHeader>
        <CardContent>
          <Form {...form}>
            <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4">
              {/* Form fields */}
              
              <div className="flex gap-3">
                <Button type="submit" disabled={createMutation.isPending || updateMutation.isPending}>
                  {profile ? "Update Profile" : "Create Profile"}
                </Button>
                {profile && (
                  <>
                    <Button type="button" variant="outline" onClick={() => setLocation("/apps/myapp")}>
                      Cancel
                    </Button>
                    {/* 🚨 REQUIRED: Delete Profile button */}
                    <Button
                      type="button"
                      variant="destructive"
                      onClick={() => setDeleteDialogOpen(true)}
                      data-testid="button-delete-profile"
                    >
                      Delete Profile
                    </Button>
                  </>
                )}
              </div>
            </form>
          </Form>
        </CardContent>
      </Card>

      {/* 🚨 REQUIRED: Delete confirmation dialog */}
      {profile && (
        <DeleteProfileDialog
          open={deleteDialogOpen}
          onOpenChange={setDeleteDialogOpen}
          onConfirm={(reason) => deleteMutation.mutate(reason)}
          appName="MyApp"
          isDeleting={deleteMutation.isPending}
        />
      )}
    </div>
  );
}
```

**🚨 TanStack Query Rules:**
- Use `queryKey: ['/api/endpoint']` for GET requests
- For hierarchical keys: `['/api/resource', id]` not `['/api/resource/${id}']`
- Always show loading states
- Use `apiRequest` from `@lib/queryClient` for mutations

#### **Step 5: Routing (`client/src/App.tsx`)**

1. Import your pages:
```typescript
import MyAppDashboard from "@/pages/myapp/dashboard";
import MyAppProfile from "@/pages/myapp/profile";
```

2. Add routes in the `Router` component (around line 55):
```typescript
{user?.inviteCodeUsed && (
  <>
    {/* Existing routes */}
    <Route path="/apps/myapp" component={MyAppDashboard} />
    <Route path="/apps/myapp/profile" component={MyAppProfile} />
  </>
)}
```

#### **Step 6: Sidebar Navigation (`client/src/components/app-sidebar.tsx`)**

1. Import icon:
```typescript
import { MyIcon } from "lucide-react";
```

2. Add to `userMenuItems` array (around line 92):
```typescript
const userMenuItems = [
  // ... existing items
  {
    title: "MyApp",
    url: "/apps/myapp",
    icon: MyIcon,
    testId: "link-myapp",
  },
];
```

3. **REQUIRED:** Add admin page to `adminMenuItems` array:
```typescript
const adminMenuItems = [
  // ... existing items
  {
    title: "MyApp Admin",
    url: "/apps/myapp/admin",
    icon: MyIcon,
    testId: "link-myapp-admin",
  },
];
```

#### **Step 7: Admin Page (`client/src/pages/myapp/admin.tsx`)**

**🚨 REQUIRED:** Create an admin interface for managing the mini-app's content/data. This should include:
- List all items/records in the app
- Create new items/records
- Edit existing items/records
- Delete items/records
- Toggle active/inactive status (if applicable)
- Any other management operations needed

Example admin page:
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { apiRequest, queryClient } from "@/lib/queryClient";
import { Link } from "wouter";

export default function MyAppAdmin() {
  const { data: items = [], isLoading } = useQuery({
    queryKey: ['/api/myapp/admin'],
  });
  
  const createMutation = useMutation({
    mutationFn: async (data) => 
      apiRequest('/api/myapp/admin', { method: 'POST', body: data }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/myapp/admin'] });
    },
  });
  
  // ... edit, delete mutations, etc.
  
  return (
    <div className="p-4 sm:p-6 md:p-8">
      <h1 className="text-2xl sm:text-3xl font-semibold mb-6">MyApp Administration</h1>
      
      {/* Admin interface */}
      
      {/* 🚨 REQUIRED: Link to announcement management */}
      <Card>
        <CardHeader>
          <CardTitle>Announcements</CardTitle>
        </CardHeader>
        <CardContent className="space-y-4">
          <p className="text-sm text-muted-foreground">
            Create and manage announcements for this mini-app.
          </p>
          <Link href="/apps/myapp/admin/announcements">
            <Button className="w-full" data-testid="button-manage-announcements">
              Manage Announcements
            </Button>
          </Link>
        </CardContent>
      </Card>
    </div>
  );
}
```

**Add admin routes in `client/src/App.tsx`:**
```typescript
<Route path="/apps/myapp/admin" component={MyAppAdmin} />
<Route path="/apps/myapp/admin/announcements" component={MyAppAdminAnnouncements} />
```

#### **Step 8: Announcement Management (`client/src/pages/myapp/admin-announcements.tsx`)**

**🚨 REQUIRED:** Every mini-app MUST have an admin announcement management page.

Create the admin announcements page following this pattern (see `client/src/pages/supportmatch/admin-announcements.tsx` for reference):

```typescript
import { useState } from "react";
import { useQuery, useMutation } from "@tanstack/react-query";
import { useForm } from "react-hook-form";
import { zodResolver } from "@hookform/resolvers/zod";
import { z } from "zod";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Form, FormControl, FormField, FormItem, FormLabel, FormMessage } from "@/components/ui/form";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/hooks/use-toast";
import { apiRequest, queryClient } from "@/lib/queryClient";
import type { MyappAnnouncement } from "@shared/schema";
import { format } from "date-fns";
import { ArrowLeft } from "lucide-react";
import { Link } from "wouter";

const announcementFormSchema = z.object({
  title: z.string().min(1, "Title is required"),
  content: z.string().min(1, "Content is required"),
  type: z.enum(["info", "warning", "maintenance", "update", "promotion"]),
  expiresAt: z.string().optional(),
});

type AnnouncementFormValues = z.infer<typeof announcementFormSchema>;

export default function MyAppAdminAnnouncements() {
  const { toast } = useToast();
  const [editingId, setEditingId] = useState<string | null>(null);

  const { data: announcements, isLoading } = useQuery<MyappAnnouncement[]>({
    queryKey: ["/api/myapp/admin/announcements"],
  });

  const form = useForm<AnnouncementFormValues>({
    resolver: zodResolver(announcementFormSchema),
    defaultValues: {
      title: "",
      content: "",
      type: "info",
      expiresAt: "",
    },
  });

  // Create, update, delete mutations following the same pattern as profile operations
  // See supportmatch/admin-announcements.tsx for complete implementation

  return (
    <div className="p-6 md:p-8 space-y-8">
      <div className="flex items-center gap-4">
        <Link href="/apps/myapp/admin">
          <Button variant="ghost" size="icon" data-testid="button-back">
            <ArrowLeft className="w-5 h-5" />
          </Button>
        </Link>
        <div>
          <h1 className="text-3xl md:text-4xl font-semibold">Manage Announcements</h1>
          <p className="text-muted-foreground">
            Create and manage MyApp announcements
          </p>
        </div>
      </div>

      {/* Form for creating/editing announcements */}
      {/* List of existing announcements with edit/delete buttons */}
    </div>
  );
}
```

**Key requirements:**
- Use the `insertMyappAnnouncementSchema` for validation
- Support all announcement types: info, warning, maintenance, update, promotion
- Include optional expiration date field
- Display active and inactive announcements
- Allow editing and deactivating announcements
- Use `AnnouncementDisplay` component for consistent styling

#### **Step 9: Display Announcements on User Pages**

**🚨 REQUIRED:** Add `AnnouncementBanner` component to the main dashboard/page of each mini-app.

Update the dashboard to display active announcements:

```typescript
import { AnnouncementBanner } from "@/components/announcement-banner";

export default function MyAppDashboard() {
  return (
    <div className="container mx-auto p-6 max-w-7xl">
      <h1 className="text-3xl font-semibold mb-6">MyApp Dashboard</h1>
      
      {/* Display active announcements at the top */}
      <AnnouncementBanner 
        apiEndpoint="/api/myapp/announcements"
        queryKey="/api/myapp/announcements"
      />
      
      {/* Rest of dashboard content */}
    </div>
  );
}
```

**Optional:** Create an announcement history page for users to view past announcements:

```typescript
import { useQuery } from "@tanstack/react-query";
import { AnnouncementDisplay } from "@/components/announcement-display";
import type { MyappAnnouncement } from "@shared/schema";

export default function MyAppAnnouncements() {
  const { data: announcements, isLoading } = useQuery<MyappAnnouncement[]>({
    queryKey: ["/api/myapp/admin/announcements"], // Admin endpoint shows all (including inactive)
  });

  if (isLoading) return <div>Loading...</div>;

  return (
    <div className="p-4 sm:p-6 md:p-8 space-y-6">
      <h1 className="text-2xl sm:text-3xl font-semibold mb-2">Announcements</h1>
      <p className="text-muted-foreground">
        View all announcements for MyApp
      </p>
      
      {announcements?.map((announcement) => (
        <AnnouncementDisplay
          key={announcement.id}
          id={announcement.id}
          title={announcement.title}
          content={announcement.content}
          type={announcement.type}
          createdAt={announcement.createdAt}
          expiresAt={announcement.expiresAt}
          showExpiration={true}
        />
      ))}
    </div>
  );
}
```

#### **Step 10: Seeding Script (`scripts/`)**
- Add a seed script for the mini-app, e.g. `scripts/seedMyApp.ts`
- Use `db` and shared `schema` to insert deterministic dummy data
- Do NOT expose seeding via API routes; seeds run via script only

#### **Step 11: Storage Implementation**

**🚨 REQUIRED:** Implement all announcement storage methods in the `DatabaseStorage` class.

Add implementation following this pattern:

```typescript
// MyApp Announcement operations
async createMyappAnnouncement(announcementData: InsertMyappAnnouncement): Promise<MyappAnnouncement> {
  const [announcement] = await db
    .insert(myappAnnouncements)
    .values(announcementData)
    .returning();
  return announcement;
}

async getActiveMyappAnnouncements(): Promise<MyappAnnouncement[]> {
  const now = new Date();
  return await db
    .select()
    .from(myappAnnouncements)
    .where(
      and(
        eq(myappAnnouncements.isActive, true),
        or(
          sql`${myappAnnouncements.expiresAt} IS NULL`,
          gte(myappAnnouncements.expiresAt, now)
        )
      )
    )
    .orderBy(desc(myappAnnouncements.createdAt));
}

async getAllMyappAnnouncements(): Promise<MyappAnnouncement[]> {
  return await db
    .select()
    .from(myappAnnouncements)
    .orderBy(desc(myappAnnouncements.createdAt));
}

async updateMyappAnnouncement(id: string, announcementData: Partial<InsertMyappAnnouncement>): Promise<MyappAnnouncement> {
  const [announcement] = await db
    .update(myappAnnouncements)
    .set({
      ...announcementData,
      updatedAt: new Date(),
    })
    .where(eq(myappAnnouncements.id, id))
    .returning();
  return announcement;
}

async deactivateMyappAnnouncement(id: string): Promise<MyappAnnouncement> {
  const [announcement] = await db
    .update(myappAnnouncements)
    .set({
      isActive: false,
      updatedAt: new Date(),
    })
    .where(eq(myappAnnouncements.id, id))
    .returning();
  return announcement;
}
```

#### **Step 12: Testing** 🧪

**🚨 REQUIRED:** Create comprehensive tests for the new mini-app before merging.

1. **Create test files** following the structure in `test/` directory:
   - `test/api/myapp.test.ts` - API endpoint tests
   - `test/client/pages/myapp/*.test.tsx` - Component tests
   - `test/e2e/myapp.spec.ts` - E2E tests (if applicable)
   - `test/integration/myapp.test.ts` - Integration tests

2. **Write tests** covering:
   - All CRUD operations (profile create, read, update, delete)
   - Authentication and authorization
   - Input validation
   - Security (SQL injection, XSS prevention)
   - Accessibility (keyboard nav, screen reader)
   - Error handling
   - Cascade anonymization on deletion

3. **Run tests** locally and ensure they pass:
   ```bash
   npm run test          # Unit/integration tests
   npm run test:e2e      # E2E tests (if configured)
   ```

4. **Verify coverage** meets requirements (90%+ for critical paths)

See the **Testing Requirements** section above for detailed testing guidelines and examples.

---

### **B. Adding Features to Existing Mini-Apps**

1. **Add table to schema** if new data model needed
2. **Add storage methods** to `IStorage` and `DatabaseStorage`
3. **Add API routes** to the mini-app's route section in `routes.ts`
4. **Create/update pages** in `client/src/pages/{mini-app}/`
5. **Update sidebar** if new navigation needed
6. **Write tests** for new functionality (unit, integration, security, accessibility)
7. **Update existing tests** if feature changes behavior
8. **Run regression tests** to ensure existing features still work

---

## 🎨 Design System Rules

**READ `design_guidelines.md` BEFORE CODING UI!**

### Critical Rules:
1. **WCAG AAA compliance** - 7:1 contrast, keyboard nav, semantic HTML
2. **No animations** - No parallax, scroll effects, or transitions (trauma-informed)
3. **Use shadcn components** - Button, Card, Badge, Form, etc. from `@/components/ui/`
4. **Tailwind spacing** - Stick to 2, 4, 6, 8, 12, 16 scale
5. **data-testid required** - Every interactive element needs unique test ID
6. **Design spec source of truth** - Follow `design_guidelines.md` for colors, spacing, components, and accessibility. Never override without updating the guidelines.
7. **Links opening in new tabs MUST use confirmation dialog** - **REQUIRED**: Any link that opens in a new tab (whether internal or external) MUST use the `useExternalLink` hook from `@/hooks/useExternalLink` which provides a standardized confirmation dialog before opening links. This includes:
   - Links to other pages within the app that open in new tabs
   - External links to other websites
   - Any clickable element that triggers `window.open()` or opens a new tab
   - The hook provides `openExternal(url)` function and `<ExternalLinkDialog />` component that must be included in the component

### Shared Field Standards
- **Country field (ALL profiles/apps):** Implement as a dropdown/select with a single, shared options source and identical ordering across the app.
  - Use a shared list of countries (single source of truth) and a shared UI control so UX and data stay consistent if users update their country in different mini-apps.
  - Do not use free-text inputs for country fields.
  - Ensure backend schemas use consistent validation for allowed country values.

### Color Scheme:
- Primary: Green (`#4ade80`)
- Background: Warm tan/canvas (`HSL 40 25% 97%`)
- Text hierarchy: Default → Secondary → Tertiary (muted)

### Component Patterns:
```typescript
// Good - Uses shadcn Button with test ID
<Button data-testid="button-submit" variant="default">Submit</Button>

// Good - Card with proper spacing
<Card className="p-6">
  <CardHeader className="space-y-2">
    <CardTitle>Title</CardTitle>
  </CardHeader>
  <CardContent className="space-y-4">
    {/* content */}
  </CardContent>
</Card>

// Good - Form with react-hook-form
const form = useForm({
  resolver: zodResolver(insertMyProfileSchema),
  defaultValues: { name: "" },
});
```

---

## 🔒 Authentication & Authorization

### Auth Levels (enforced by middleware):
1. **Unauthenticated** → Landing page only
2. **Authenticated (no invite)** → Invite redemption page only
3. **Authenticated (with invite)** → Full user features
4. **Admin** → All features + admin dashboard

### Usage:
```typescript
// Frontend - useAuth hook
import { useAuth } from "@/hooks/useAuth";

const { user, isAdmin, loading } = useAuth();

// Backend - Middleware
app.get('/api/protected', isAuthenticated, async (req: any, res) => {
  const userId = getUserId(req); // req.user.claims.sub
});

app.get('/api/admin-only', isAdmin, async (req: any, res) => {
  // Admin only
});
```

---

## 🛡️ Anti-Scraping Protection for Public Endpoints

**🚨 REQUIRED:** All public endpoints (endpoints accessible without authentication) MUST implement comprehensive anti-scraping protection to prevent bulk data harvesting and protect user privacy.

### Protection Requirements:

1. **Rate Limiting** - Apply appropriate rate limiters from `server/rateLimiter.ts`:
   - **Listing endpoints** (`/api/{app}/public`): Use `publicListingLimiter` (10 requests/15min per IP)
   - **Individual item endpoints** (`/api/{app}/public/:id`): Use `publicItemLimiter` (50 requests/15min per IP)

2. **Request Fingerprinting** - Automatically enabled via `fingerprintRequests` middleware in `server/antiScraping.ts`:
   - Tracks IP, user-agent, headers, referer, and request patterns
   - Detects suspicious behavior (rapid requests, missing headers, repetitive patterns)

3. **Data Obfuscation** - Implement in public listing endpoints:
   - **Rotate display order**: Use `rotateDisplayOrder()` from `server/dataObfuscation.ts` to periodically shuffle results
   - **Add delays**: Use `addAntiScrapingDelay()` based on request suspicion level
   - **Bot detection**: Use `isLikelyBot()` to identify automated requests

### Implementation Pattern:

```typescript
import { publicListingLimiter, publicItemLimiter } from "./rateLimiter";
import { rotateDisplayOrder, addAntiScrapingDelay, isLikelyBot } from "./dataObfuscation";

// Listing endpoint example
app.get('/api/myapp/public', publicListingLimiter, async (req, res) => {
  try {
    // Add delay for suspicious requests
    const isSuspicious = (req as any).isSuspicious || false;
    const userAgent = req.headers['user-agent'];
    const accept = req.headers['accept'];
    const acceptLang = req.headers['accept-language'];
    const likelyBot = isLikelyBot(userAgent, accept, acceptLang);
    
    if (isSuspicious || likelyBot) {
      await addAntiScrapingDelay(true, 200, 800);
    } else {
      await addAntiScrapingDelay(false, 50, 200);
    }

    const items = await storage.listPublicItems();
    
    // Rotate display order to make scraping harder
    const rotated = rotateDisplayOrder(items);
    
    res.json(rotated);
  } catch (error) {
    console.error("Error fetching public items:", error);
    res.status(500).json({ message: "Failed to fetch items" });
  }
});

// Individual item endpoint example
app.get('/api/myapp/public/:id', publicItemLimiter, async (req, res) => {
  try {
    const item = await storage.getPublicItemById(req.params.id);
    if (!item || !item.isPublic) {
      return res.status(404).json({ message: "Item not found" });
    }
    res.json(item);
  } catch (error) {
    console.error("Error fetching public item:", error);
    res.status(500).json({ message: "Failed to fetch item" });
  }
});
```

### Key Points:

- **`fingerprintRequests` middleware is already applied globally** - All requests are automatically fingerprinted
- **Rate limiters must be applied BEFORE route handlers** - Place them as the first middleware
- **Display order rotation uses time-based seeding** - Results shuffle every 5 minutes automatically
- **Delays are subtle** - Legitimate users won't notice, but bots/scrapers will be slowed
- **Monitoring available** - Admins can view suspicious patterns via `/api/admin/anti-scraping/patterns`

### Monitoring:

Admin endpoints for monitoring suspicious activity:
- `GET /api/admin/anti-scraping/patterns` - View all suspicious patterns
- `GET /api/admin/anti-scraping/patterns?ip=X` - View patterns for specific IP
- `DELETE /api/admin/anti-scraping/patterns` - Clear all patterns
- `DELETE /api/admin/anti-scraping/patterns?ip=X` - Clear patterns for specific IP

**🚨 CRITICAL:** Never create public endpoints without these protection measures. User privacy and safety depend on preventing bulk data harvesting.

---

## 📋 Database Migration Workflow

**🚨 NEVER manually write SQL migrations!**

1. Update `shared/schema.ts`
2. Run: `npm run db:push` (or `npm run db:push --force` if data loss warning)
3. That's it - Drizzle handles everything

**NEVER change ID column types** (serial ↔ varchar) - This breaks existing data!

---

## 🧪 Testing Requirements

**🚨 CRITICAL:** Every new feature MUST include appropriate tests. Testing ensures safety, security, and reliability for vulnerable users.

### **Comprehensive Testing Plan**

See `TESTING_PLAN.md` for the complete testing strategy covering:
- Functional Testing
- Usability Testing
- Performance Testing
- Security Testing
- AI Model Evaluation (if applicable)
- Regression Testing
- Integration Testing

### **Testing Requirements for New Features**

When adding any new feature, you MUST create tests for:

#### **1. Functional Tests**

**For API Endpoints:**
```typescript
// Example: test/api/myapp.test.ts
import { describe, it, expect } from 'vitest';
import { storage } from '../server/storage';
import { db } from '../server/db';

describe('MyApp API', () => {
  it('should create profile', async () => {
    const profile = await storage.createMyAppProfile({
      userId: 'test-user-id',
      // ... other fields
    });
    expect(profile).toBeDefined();
    expect(profile.userId).toBe('test-user-id');
  });

  it('should enforce authentication', async () => {
    // Test that unauthenticated requests are rejected
  });

  it('should validate input with Zod schema', async () => {
    // Test that invalid input is rejected
  });
});
```

**For Frontend Components:**
```typescript
// Example: test/client/pages/myapp/profile.test.tsx
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import MyAppProfile from '@/pages/myapp/profile';

describe('MyAppProfile', () => {
  it('should render create form when no profile exists', () => {
    render(<MyAppProfile />);
    expect(screen.getByTestId('button-submit')).toHaveTextContent('Create Profile');
  });

  it('should render edit form when profile exists', () => {
    // Test with existing profile
  });

  it('should show delete button only when profile exists', () => {
    // Test delete button visibility
  });
});
```

#### **2. Security Tests**

**🚨 REQUIRED for all endpoints:**
- **Authorization tests**: Verify users can only access their own data
- **Input validation tests**: Test SQL injection, XSS prevention
- **Authentication tests**: Verify protected endpoints require auth
- **Privacy tests**: Verify private data not exposed

```typescript
describe('Security', () => {
  it('should prevent unauthorized access to other users data', async () => {
    // User A should not access User B's profile
  });

  it('should sanitize user input to prevent XSS', () => {
    // Test that script tags are escaped
  });

  it('should prevent SQL injection', async () => {
    // Test that malicious SQL is handled safely
  });
});
```

#### **3. Accessibility Tests**

**🚨 REQUIRED for all UI components:**
- **Keyboard navigation**: All functionality accessible via keyboard
- **Screen reader compatibility**: Test with NVDA/JAWS/VoiceOver
- **Color contrast**: Verify WCAG AAA compliance (7:1 ratio)
- **Focus management**: Verify focus indicators visible

```typescript
import { axe, toHaveNoViolations } from 'jest-axe';

describe('Accessibility', () => {
  it('should have no accessibility violations', async () => {
    const { container } = render(<MyAppProfile />);
    const results = await axe(container);
    expect(results).toHaveNoViolations();
  });

  it('should be keyboard navigable', () => {
    // Test Tab navigation, Enter/Space activation
  });
});
```

#### **4. Integration Tests**

**For database operations:**
```typescript
describe('Storage Integration', () => {
  it('should create profile and retrieve it', async () => {
    const created = await storage.createMyAppProfile({...});
    const retrieved = await storage.getMyAppProfile(created.userId);
    expect(retrieved).toEqual(created);
  });

  it('should anonymize related data on profile deletion', async () => {
    // Test cascade anonymization
  });
});
```

**For API-Frontend integration:**
```typescript
// E2E test with Playwright
import { test, expect } from '@playwright/test';

test('complete profile creation flow', async ({ page }) => {
  await page.goto('/apps/myapp/profile');
  await page.fill('[data-testid="input-name"]', 'Test User');
  await page.click('[data-testid="button-submit"]');
  await expect(page.locator('[data-testid="toast-success"]')).toBeVisible();
});
```

#### **5. Performance Tests**

**For API endpoints:**
- Test response times (target: < 500ms p95)
- Test under load (50+ concurrent users)
- Test database query performance

**For frontend:**
- Test bundle size (< 200KB gzipped)
- Test Time to Interactive (< 3s)
- Test First Contentful Paint (< 1.5s)

#### **6. Regression Tests**

**Required for:**
- Profile CRUD operations
- Authentication flows
- Admin actions
- Public endpoint access
- Profile deletion with cascade

### **Test File Structure**

```
project-root/
├── test/
│   ├── api/              ← API endpoint tests (Vitest)
│   │   ├── auth.test.ts
│   │   └── myapp.test.ts
│   ├── client/           ← Frontend component tests (Vitest + React Testing Library)
│   │   ├── components/
│   │   └── pages/
│   ├── e2e/              ← End-to-end tests (Playwright)
│   │   ├── auth.spec.ts
│   │   └── myapp.spec.ts
│   ├── integration/      ← Integration tests (Vitest)
│   │   └── storage.test.ts
│   ├── security/         ← Security-specific tests
│   │   └── injection.test.ts
│   └── fixtures/         ← Test data and helpers
│       └── testData.ts
```

### **Test Execution**

**Pre-commit (via Husky):**
- Run linting
- Run type checking
- Run unit tests

**CI/CD Pipeline:**
- Run full test suite on PRs
- Run E2E tests on PRs
- Block merge if tests fail
- Generate coverage reports

**Before Release:**
- Run smoke tests (< 5 minutes)
- Run regression test checklist (manual)
- Verify all critical paths tested

### **Test Coverage Requirements**

- **Critical paths**: 90%+ coverage
  - Authentication/authorization
  - Profile CRUD operations
  - Admin actions
  - Profile deletion
  - Public endpoint protection

- **Overall codebase**: 70%+ coverage

### **Testing Tools**

- **Unit/Integration**: Vitest
- **E2E**: Playwright
- **Accessibility**: axe-core (via Playwright)
- **API Testing**: k6 or Artillery (for load testing)
- **Coverage**: Vitest coverage

### **Test Naming Conventions**

- Test files: `*.test.ts` or `*.spec.ts`
- Test descriptions: `should [expected behavior]`
- Group related tests with `describe` blocks
- Use clear, descriptive test names

### **Common Testing Patterns**

**Forms:**
```typescript
const form = useForm({
  resolver: zodResolver(insertSchema),
  defaultValues: { field: "" },
});

const onSubmit = async (data: InsertType) => {
  mutation.mutate(data);
};
```

**Mutations:**
```typescript
const mutation = useMutation({
  mutationFn: async (data: InsertType) => 
    apiRequest('/api/endpoint', { method: 'POST', body: data }),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['/api/endpoint'] });
    toast({ title: "Success!" });
  },
});
```

**Testing with TanStack Query:**
```typescript
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const createTestQueryClient = () => new QueryClient({
  defaultOptions: {
    queries: { retry: false },
    mutations: { retry: false },
  },
});

// Use in tests
render(
  <QueryClientProvider client={createTestQueryClient()}>
    <Component />
  </QueryClientProvider>
);
```

### **🚨 Testing Checklist for New Features**

When adding a new feature, ensure:

- [ ] **Unit tests** for storage methods (create, read, update, delete)
- [ ] **API tests** for all endpoints (GET, POST, PUT, DELETE)
- [ ] **Authorization tests** (users can only access own data)
- [ ] **Input validation tests** (Zod schema validation)
- [ ] **Security tests** (SQL injection, XSS prevention)
- [ ] **Accessibility tests** (keyboard nav, screen reader, contrast)
- [ ] **Integration tests** (end-to-end workflows)
- [ ] **Error handling tests** (invalid input, not found, unauthorized)
- [ ] **Edge case tests** (empty data, null values, boundary conditions)
- [ ] **Performance tests** (response times, load handling)
- [ ] **Regression tests** (existing features not broken)

**For UI components:**
- [ ] Component renders correctly
- [ ] Loading states work
- [ ] Error states display properly
- [ ] Forms validate input
- [ ] Success/error toasts appear
- [ ] Navigation works correctly
- [ ] All `data-testid` attributes present

**For public endpoints:**
- [ ] Rate limiting enforced
- [ ] Anti-scraping protection works
- [ ] Display order rotation functions
- [ ] Bot detection triggers delays

### **Writing Maintainable Tests**

1. **Use descriptive names**: Test names should clearly describe what they test
2. **Arrange-Act-Assert pattern**: Structure tests clearly
3. **Test one thing**: Each test should verify one behavior
4. **Use fixtures**: Reuse test data helpers
5. **Mock external services**: Don't call real APIs/databases in unit tests
6. **Clean up**: Remove test data after tests
7. **Keep tests fast**: Unit tests should run in < 100ms each
8. **Document complex tests**: Add comments for non-obvious test logic

### **When to Write Tests**

- **Always**: Before merging new features
- **Always**: For security-critical code
- **Always**: For authentication/authorization
- **Always**: For data deletion/anonymization
- **Recommended**: For all API endpoints
- **Recommended**: For complex business logic
- **Optional**: For simple CRUD operations (if covered by integration tests)

---

## 🚨 Common Mistakes to Avoid

1. **Don't modify these files:**
   - `vite.config.ts` (already configured)
   - `server/vite.ts` (already configured)
   - `drizzle.config.ts` (already configured)

2. **Don't create separate route files** - All routes go in `server/routes.ts`

3. **Don't bypass storage layer** - Always use `storage.methodName()`, never `db.query()` in routes

4. **Don't use `process.env` in frontend** - Use `import.meta.env.VITE_*`

5. **Don't forget Zod validation** - Always validate request bodies with schemas

6. **Don't skip test IDs** - Every interactive element needs `data-testid`

7. **Don't mix mini-app concerns** - Keep each mini-app's code separate

---

## 📚 Existing Mini-Apps Reference

Study these for patterns:

1. **SupportMatch** (`/apps/supportmatch`)
   - Profiles with edit/delete functionality
   - Partnerships, messaging, exclusions, reports
   - Complex matching algorithm
   - Admin moderation tools
   - Profile deletion with cascade anonymization
   - ✅ Announcement system with admin management

2. **SleepStories** (`/apps/sleepstories`)
   - Audio content library
   - Wistia integration
   - Category system
   - Note: Does not require user profiles (content-only app)
   - ✅ Announcement system with admin management

3. **LightHouse** (`/apps/lighthouse`)
   - Profiles with edit/delete functionality
   - Dual-role system (seeker/host)
   - Property listings
   - Match requests
   - Conditional dashboard
   - Profile deletion with cascade anonymization
   - ✅ Announcement system with admin management

4. **SocketRelay** (`/apps/socketrelay`)
   - Profiles with edit/delete functionality
   - Request/fulfillment system
   - Messaging
   - Profile deletion with cascade anonymization
   - ✅ Announcement system with admin management

5. **Directory** (`/apps/directory`)
   - Profiles with edit/delete functionality
   - Public/private profiles
   - Admin/public views
   - Profile deletion with logging
   - ✅ Announcement system with admin management

6. **ChatGroups** (`/apps/chatgroups`)
   - Signal.org group links
   - Public listing of active groups
   - Admin management interface
   - Note: Does not require user profiles (public group listing app)
   - ✅ Announcement system with admin management

**🚨 Profile Requirements:**
- SupportMatch: ✅ Has profile with edit/delete
- LightHouse: ✅ Has profile with edit/delete
- SocketRelay: ✅ Has profile with edit/delete
- Directory: ✅ Has profile with edit/delete
- SleepStories: ❌ No profile (content-only)
- ChatGroups: ❌ No profile (public listing only)

---

## ✅ Checklist for New Features

### **Implementation Checklist**

- [ ] Schema added to `shared/schema.ts` with proper relations & types (including profile table)
- [ ] **Announcement table added to schema** - REQUIRED for every mini-app (`{app}Announcements` table)
- [ ] Storage methods added to interface & implemented (including profile CRUD and delete with cascade)
- [ ] **Announcement storage methods added** - REQUIRED (create, getActive, getAll, update, deactivate)
- [ ] API routes added with Zod validation & error handling (GET, POST, PUT, DELETE for profile)
- [ ] **Announcement API routes added** - REQUIRED (`/api/{app}/announcements` and `/api/{app}/admin/announcements`)
- [ ] **Profile page created with Edit and Delete buttons** - REQUIRED for every mini-app
- [ ] **Delete Profile button uses `DeleteProfileDialog` component** - REQUIRED
- [ ] **Delete profile method anonymizes related data** (replaces user IDs with `deleted_user_[random_string]`)
- [ ] **Delete profile method logs deletion** using `logProfileDeletion()`
- [ ] **Public endpoints implement anti-scraping protection** (rate limiting, fingerprinting, data obfuscation)
- [ ] Frontend pages created following design guidelines
- [ ] **AnnouncementBanner component added to dashboard** - REQUIRED (displays active announcements)
- [ ] **Admin announcement management page created** - REQUIRED (`admin-announcements.tsx`)
- [ ] Routes registered in `App.tsx` (including profile route and announcement admin route)
- [ ] Sidebar navigation updated
- [ ] **Link to announcement management added to admin page** - REQUIRED
- [ ] Seed script created in `scripts/` for the mini-app
- [ ] Country fields use the shared dropdown and options list
- [ ] External links use the `useExternalLink` hook with confirmation dialog
- [ ] All interactive elements have `data-testid` attributes
- [ ] WCAG AAA compliance verified (contrast, keyboard nav)
- [ ] Loading states implemented
- [ ] Error handling implemented
- [ ] Database schema pushed: `npm run db:push`

### **Testing Checklist** 🧪

**🚨 REQUIRED:** All features must include appropriate tests before merging.

- [ ] **Unit tests** for storage methods (create, read, update, delete operations)
- [ ] **API endpoint tests** for all routes (GET, POST, PUT, DELETE)
  - [ ] Test authentication requirements
  - [ ] Test authorization (users can only access own data)
  - [ ] Test input validation (Zod schema)
  - [ ] Test error handling (invalid input, not found, unauthorized)
- [ ] **Security tests**
  - [ ] Test SQL injection prevention
  - [ ] Test XSS prevention
  - [ ] Test unauthorized access prevention
  - [ ] Test privacy settings enforcement
- [ ] **Accessibility tests**
  - [ ] Test keyboard navigation
  - [ ] Test screen reader compatibility (axe-core)
  - [ ] Test color contrast (WCAG AAA - 7:1 ratio)
  - [ ] Test focus management
- [ ] **Integration tests**
  - [ ] Test database operations (create → retrieve → update → delete)
  - [ ] Test cascade anonymization on profile deletion
  - [ ] Test API-Frontend integration
- [ ] **E2E tests** for critical user flows (using Playwright)
  - [ ] Test complete profile creation flow
  - [ ] Test profile update flow
  - [ ] Test profile deletion flow
- [ ] **Performance tests** (if applicable)
  - [ ] Test API response times (< 500ms p95)
  - [ ] Test under load (50+ concurrent users)
- [ ] **Regression tests** - Verify existing features still work
- [ ] **Test coverage** meets requirements (90%+ for critical paths, 70%+ overall)
- [ ] All tests pass locally before committing
- [ ] Test files follow naming conventions (`*.test.ts` or `*.spec.ts`)

---

## 🎯 When in Doubt

1. **Look at existing code** - Study SupportMatch/LightHouse patterns
2. **Read design_guidelines.md** - For all UI/UX decisions
3. **Read TESTING_PLAN.md** - For comprehensive testing strategy
4. **Follow the sequence** - Schema → Storage → Routes → Pages → Navigation → Tests
5. **Keep it modular** - Each mini-app is independent
6. **Test as you build** - Write tests alongside implementation, use `data-testid` for testability
7. **Security first** - Always test authentication, authorization, and input validation
8. **Accessibility always** - Test keyboard nav and screen readers for every UI component

---

**This platform serves vulnerable users. Every line of code should prioritize safety, privacy, and dignity.**
