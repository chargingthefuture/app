---
alwaysApply: true
---

# Context Prompt for Cursor AI - Psyop-Free Ecosystem

## 🎯 Application Overview

This is a **secure, invite-only platform** for survivors of human trafficking, built as a **WeChat-style super app** where each service operates as an independent mini-app sharing core platform functionalities.

**Key Values:** Safety, privacy, dignity, accessibility (WCAG AAA), trauma-informed design

**Tech Stack:**
- Frontend: React + TypeScript + Vite + Wouter (routing) + TanStack Query (state) + shadcn/ui + Tailwind
- Backend: Express.js + TypeScript + Replit Auth (OIDC) + PostgreSQL (Neon) + Drizzle ORM
- Architecture: Monorepo with shared types between frontend/backend

---

## 🏗️ Critical Architecture Patterns

### 1. **Mini-App (Super App) Architecture**

Each service (SupportMatch, SleepStories, LightHouse, SocketRelay, Directory, ChatGroups) is a **self-contained mini-app** with its own:
- Database tables in `shared/schema.ts`
- Storage methods in `server/storage.ts`
- API routes in `server/routes.ts`
- Frontend pages in `client/src/pages/{mini-app-name}/`
- Sidebar navigation entry in `client/src/components/app-sidebar.tsx`

**🚨 CRITICAL:** Never mix concerns between mini-apps. Each operates independently.

---

## 📂 File Structure & Responsibilities

```
project-root/
├── shared/
│   └── schema.ts          ← ALL database tables, types, Zod schemas
├── server/
│   ├── storage.ts         ← Data access layer (repository pattern)
│   ├── routes.ts          ← ALL API endpoints
│   ├── replitAuth.ts      ← Auth middleware (isAuthenticated, isAdmin)
│   └── index.ts           ← Express setup (DON'T modify)
├── client/src/
│   ├── App.tsx            ← Main router & layout (SidebarProvider here)
│   ├── components/
│   │   ├── app-sidebar.tsx  ← Navigation menu (add new routes here)
│   │   └── ui/            ← shadcn components (reusable)
│   ├── pages/
│   │   ├── home.tsx       ← User dashboard
│   │   ├── admin/         ← Platform-wide admin pages
│   │   └── {mini-app}/    ← Mini-app specific pages
│   ├── hooks/
│   │   └── useAuth.ts     ← Auth hook (user, isAdmin, loading)
│   └── lib/
│       └── queryClient.ts ← TanStack Query setup
├── scripts/                ← App seeders and utility scripts (seed per mini-app)
└── design_guidelines.md   ← Design system (READ THIS!)
```

---

## 🔧 How to Add a New Feature

### **A. Adding a New Mini-App**

**🚨 REQUIRED:** Every new mini-app MUST have:
1. **User-facing pages** - Where regular users interact with the app
2. **Admin page** - A dedicated admin interface under the Administration section for managing the app's content/data

Follow this exact sequence:

#### **Step 1: Database Schema (`shared/schema.ts`)**
Add tables at the bottom, following this pattern:

```typescript
// ========================================
// {MINI_APP_NAME} APP TABLES
// ========================================

export const myAppProfiles = pgTable("my_app_profiles", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  userId: varchar("user_id").notNull().unique().references(() => users.id),
  // ... mini-app specific fields
  createdAt: timestamp("created_at").defaultNow().notNull(),
  updatedAt: timestamp("updated_at").defaultNow().notNull(),
});

// Define relations
export const myAppProfilesRelations = relations(myAppProfiles, ({ one }) => ({
  user: one(users, {
    fields: [myAppProfiles.userId],
    references: [users.id],
  }),
}));

// Create insert schema (for validation)
export const insertMyAppProfileSchema = createInsertSchema(myAppProfiles).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// Export types
export type InsertMyAppProfile = z.infer<typeof insertMyAppProfileSchema>;
export type MyAppProfile = typeof myAppProfiles.$inferSelect;
```

**🚨 IMPORTANT:** Always use `varchar("id").primaryKey().default(sql\`gen_random_uuid()\`)` for IDs to match existing pattern.

#### **Step 2: Storage Interface (`server/storage.ts`)**

1. Import your new tables/types at the top
2. Add methods to `IStorage` interface (around line 74):
```typescript
export interface IStorage {
  // ... existing methods
  
  // MyApp operations
  getMyAppProfile(userId: string): Promise<MyAppProfile | undefined>;
  createMyAppProfile(profile: InsertMyAppProfile): Promise<MyAppProfile>;
  updateMyAppProfile(id: string, profile: Partial<InsertMyAppProfile>): Promise<MyAppProfile>;
  deleteMyAppProfile(id: string): Promise<void>;
}
```

3. Implement in `DatabaseStorage` class (around line 200+):
```typescript
class DatabaseStorage implements IStorage {
  // ... existing methods
  
  async getMyAppProfile(userId: string): Promise<MyAppProfile | undefined> {
    const [profile] = await db
      .select()
      .from(myAppProfiles)
      .where(eq(myAppProfiles.userId, userId));
    return profile;
  }
  
  // ... implement other methods
}
```

#### **Step 3: API Routes (`server/routes.ts`)**

1. Import schemas at top:
```typescript
import { insertMyAppProfileSchema } from "@shared/schema";
```

2. Add routes (group them together, around line 500+):
```typescript
// ========================================
// MyApp Routes
// ========================================

app.get('/api/myapp/profile', isAuthenticated, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const profile = await storage.getMyAppProfile(userId);
    res.json(profile);
  } catch (error: any) {
    console.error("Error fetching MyApp profile:", error);
    res.status(500).json({ message: error.message });
  }
});

app.post('/api/myapp/profile', isAuthenticated, async (req: any, res) => {
  try {
    const userId = getUserId(req);
    const validatedData = insertMyAppProfileSchema.parse(req.body);
    const profile = await storage.createMyAppProfile({
      ...validatedData,
      userId,
    });
    res.json(profile);
  } catch (error: any) {
    console.error("Error creating MyApp profile:", error);
    res.status(500).json({ message: error.message });
  }
});
```

**🚨 Pattern:** Always validate with Zod schemas, use `getUserId(req)`, wrap in try/catch

#### **Step 4: Frontend Pages (`client/src/pages/myapp/`)**

Create folder: `client/src/pages/myapp/`

Example dashboard (`dashboard.tsx`):
```typescript
import { useQuery } from "@tanstack/react-query";
import { useAuth } from "@/hooks/useAuth";
import { Card, CardHeader, CardTitle, CardContent } from "@/components/ui/card";

export default function MyAppDashboard() {
  const { user } = useAuth();
  
  const { data: profile, isLoading } = useQuery({
    queryKey: ['/api/myapp/profile'],
    enabled: !!user,
  });
  
  if (isLoading) return <div>Loading...</div>;
  
  return (
    <div className="container mx-auto p-6 max-w-7xl">
      <h1 className="text-3xl font-semibold mb-6">MyApp Dashboard</h1>
      <Card>
        <CardHeader>
          <CardTitle>Welcome to MyApp</CardTitle>
        </CardHeader>
        <CardContent>
          {/* Your content */}
        </CardContent>
      </Card>
    </div>
  );
}
```

**🚨 TanStack Query Rules:**
- Use `queryKey: ['/api/endpoint']` for GET requests
- For hierarchical keys: `['/api/resource', id]` not `['/api/resource/${id}']`
- Always show loading states
- Use `apiRequest` from `@lib/queryClient` for mutations

#### **Step 5: Routing (`client/src/App.tsx`)**

1. Import your pages:
```typescript
import MyAppDashboard from "@/pages/myapp/dashboard";
import MyAppProfile from "@/pages/myapp/profile";
```

2. Add routes in the `Router` component (around line 55):
```typescript
{user?.inviteCodeUsed && (
  <>
    {/* Existing routes */}
    <Route path="/apps/myapp" component={MyAppDashboard} />
    <Route path="/apps/myapp/profile" component={MyAppProfile} />
  </>
)}
```

#### **Step 6: Sidebar Navigation (`client/src/components/app-sidebar.tsx`)**

1. Import icon:
```typescript
import { MyIcon } from "lucide-react";
```

2. Add to `userMenuItems` array (around line 92):
```typescript
const userMenuItems = [
  // ... existing items
  {
    title: "MyApp",
    url: "/apps/myapp",
    icon: MyIcon,
    testId: "link-myapp",
  },
];
```

3. **REQUIRED:** Add admin page to `adminMenuItems` array:
```typescript
const adminMenuItems = [
  // ... existing items
  {
    title: "MyApp Admin",
    url: "/apps/myapp/admin",
    icon: MyIcon,
    testId: "link-myapp-admin",
  },
];
```

#### **Step 7: Admin Page (`client/src/pages/myapp/admin.tsx`)**

**🚨 REQUIRED:** Create an admin interface for managing the mini-app's content/data. This should include:
- List all items/records in the app
- Create new items/records
- Edit existing items/records
- Delete items/records
- Toggle active/inactive status (if applicable)
- Any other management operations needed

Example admin page:
```typescript
import { useQuery, useMutation } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { apiRequest, queryClient } from "@/lib/queryClient";

export default function MyAppAdmin() {
  const { data: items = [], isLoading } = useQuery({
    queryKey: ['/api/myapp/admin'],
  });
  
  const createMutation = useMutation({
    mutationFn: async (data) => 
      apiRequest('/api/myapp/admin', { method: 'POST', body: data }),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['/api/myapp/admin'] });
    },
  });
  
  // ... edit, delete mutations, etc.
  
  return (
    <div className="p-4 sm:p-6 md:p-8">
      <h1 className="text-2xl sm:text-3xl font-semibold mb-6">MyApp Administration</h1>
      {/* Admin interface */}
    </div>
  );
}
```

**Add admin route in `client/src/App.tsx`:**
```typescript
<Route path="/apps/myapp/admin" component={MyAppAdmin} />
```

#### **Step 8: Seeding Script (`scripts/`)**
- Add a seed script for the mini-app, e.g. `scripts/seedMyApp.ts`
- Use `db` and shared `schema` to insert deterministic dummy data
- Do NOT expose seeding via API routes; seeds run via script only

---

### **B. Adding Features to Existing Mini-Apps**

1. **Add table to schema** if new data model needed
2. **Add storage methods** to `IStorage` and `DatabaseStorage`
3. **Add API routes** to the mini-app's route section in `routes.ts`
4. **Create/update pages** in `client/src/pages/{mini-app}/`
5. **Update sidebar** if new navigation needed

---

## 🎨 Design System Rules

**READ `design_guidelines.md` BEFORE CODING UI!**

### Critical Rules:
1. **WCAG AAA compliance** - 7:1 contrast, keyboard nav, semantic HTML
2. **No animations** - No parallax, scroll effects, or transitions (trauma-informed)
3. **Use shadcn components** - Button, Card, Badge, Form, etc. from `@/components/ui/`
4. **Tailwind spacing** - Stick to 2, 4, 6, 8, 12, 16 scale
5. **data-testid required** - Every interactive element needs unique test ID
6. **Design spec source of truth** - Follow `design_guidelines.md` for colors, spacing, components, and accessibility. Never override without updating the guidelines.
7. **External links must use confirmation dialog** - All external links that open in new tabs must use the `useExternalLink` hook from `@/hooks/useExternalLink` which provides a standardized confirmation dialog before opening links.

### Shared Field Standards
- **Country field (ALL profiles/apps):** Implement as a dropdown/select with a single, shared options source and identical ordering across the app.
  - Use a shared list of countries (single source of truth) and a shared UI control so UX and data stay consistent if users update their country in different mini-apps.
  - Do not use free-text inputs for country fields.
  - Ensure backend schemas use consistent validation for allowed country values.

### Color Scheme:
- Primary: Green (`#4ade80`)
- Background: Warm tan/canvas (`HSL 40 25% 97%`)
- Text hierarchy: Default → Secondary → Tertiary (muted)

### Component Patterns:
```typescript
// Good - Uses shadcn Button with test ID
<Button data-testid="button-submit" variant="default">Submit</Button>

// Good - Card with proper spacing
<Card className="p-6">
  <CardHeader className="space-y-2">
    <CardTitle>Title</CardTitle>
  </CardHeader>
  <CardContent className="space-y-4">
    {/* content */}
  </CardContent>
</Card>

// Good - Form with react-hook-form
const form = useForm({
  resolver: zodResolver(insertMyProfileSchema),
  defaultValues: { name: "" },
});
```

---

## 🔒 Authentication & Authorization

### Auth Levels (enforced by middleware):
1. **Unauthenticated** → Landing page only
2. **Authenticated (no invite)** → Invite redemption page only
3. **Authenticated (with invite)** → Full user features
4. **Admin** → All features + admin dashboard

### Usage:
```typescript
// Frontend - useAuth hook
import { useAuth } from "@/hooks/useAuth";

const { user, isAdmin, loading } = useAuth();

// Backend - Middleware
app.get('/api/protected', isAuthenticated, async (req: any, res) => {
  const userId = getUserId(req); // req.user.claims.sub
});

app.get('/api/admin-only', isAdmin, async (req: any, res) => {
  // Admin only
});
```

---

## 🛡️ Anti-Scraping Protection for Public Endpoints

**🚨 REQUIRED:** All public endpoints (endpoints accessible without authentication) MUST implement comprehensive anti-scraping protection to prevent bulk data harvesting and protect user privacy.

### Protection Requirements:

1. **Rate Limiting** - Apply appropriate rate limiters from `server/rateLimiter.ts`:
   - **Listing endpoints** (`/api/{app}/public`): Use `publicListingLimiter` (10 requests/15min per IP)
   - **Individual item endpoints** (`/api/{app}/public/:id`): Use `publicItemLimiter` (50 requests/15min per IP)

2. **Request Fingerprinting** - Automatically enabled via `fingerprintRequests` middleware in `server/antiScraping.ts`:
   - Tracks IP, user-agent, headers, referer, and request patterns
   - Detects suspicious behavior (rapid requests, missing headers, repetitive patterns)

3. **Data Obfuscation** - Implement in public listing endpoints:
   - **Rotate display order**: Use `rotateDisplayOrder()` from `server/dataObfuscation.ts` to periodically shuffle results
   - **Add delays**: Use `addAntiScrapingDelay()` based on request suspicion level
   - **Bot detection**: Use `isLikelyBot()` to identify automated requests

### Implementation Pattern:

```typescript
import { publicListingLimiter, publicItemLimiter } from "./rateLimiter";
import { rotateDisplayOrder, addAntiScrapingDelay, isLikelyBot } from "./dataObfuscation";

// Listing endpoint example
app.get('/api/myapp/public', publicListingLimiter, async (req, res) => {
  try {
    // Add delay for suspicious requests
    const isSuspicious = (req as any).isSuspicious || false;
    const userAgent = req.headers['user-agent'];
    const accept = req.headers['accept'];
    const acceptLang = req.headers['accept-language'];
    const likelyBot = isLikelyBot(userAgent, accept, acceptLang);
    
    if (isSuspicious || likelyBot) {
      await addAntiScrapingDelay(true, 200, 800);
    } else {
      await addAntiScrapingDelay(false, 50, 200);
    }

    const items = await storage.listPublicItems();
    
    // Rotate display order to make scraping harder
    const rotated = rotateDisplayOrder(items);
    
    res.json(rotated);
  } catch (error) {
    console.error("Error fetching public items:", error);
    res.status(500).json({ message: "Failed to fetch items" });
  }
});

// Individual item endpoint example
app.get('/api/myapp/public/:id', publicItemLimiter, async (req, res) => {
  try {
    const item = await storage.getPublicItemById(req.params.id);
    if (!item || !item.isPublic) {
      return res.status(404).json({ message: "Item not found" });
    }
    res.json(item);
  } catch (error) {
    console.error("Error fetching public item:", error);
    res.status(500).json({ message: "Failed to fetch item" });
  }
});
```

### Key Points:

- **`fingerprintRequests` middleware is already applied globally** - All requests are automatically fingerprinted
- **Rate limiters must be applied BEFORE route handlers** - Place them as the first middleware
- **Display order rotation uses time-based seeding** - Results shuffle every 5 minutes automatically
- **Delays are subtle** - Legitimate users won't notice, but bots/scrapers will be slowed
- **Monitoring available** - Admins can view suspicious patterns via `/api/admin/anti-scraping/patterns`

### Monitoring:

Admin endpoints for monitoring suspicious activity:
- `GET /api/admin/anti-scraping/patterns` - View all suspicious patterns
- `GET /api/admin/anti-scraping/patterns?ip=X` - View patterns for specific IP
- `DELETE /api/admin/anti-scraping/patterns` - Clear all patterns
- `DELETE /api/admin/anti-scraping/patterns?ip=X` - Clear patterns for specific IP

**🚨 CRITICAL:** Never create public endpoints without these protection measures. User privacy and safety depend on preventing bulk data harvesting.

---

## 📋 Database Migration Workflow

**🚨 NEVER manually write SQL migrations!**

1. Update `shared/schema.ts`
2. Run: `npm run db:push` (or `npm run db:push --force` if data loss warning)
3. That's it - Drizzle handles everything

**NEVER change ID column types** (serial ↔ varchar) - This breaks existing data!

---

## 🧪 Testing Patterns

### Forms:
```typescript
const form = useForm({
  resolver: zodResolver(insertSchema),
  defaultValues: { field: "" },
});

const onSubmit = async (data: InsertType) => {
  mutation.mutate(data);
};
```

### Mutations:
```typescript
const mutation = useMutation({
  mutationFn: async (data: InsertType) => 
    apiRequest('/api/endpoint', { method: 'POST', body: data }),
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['/api/endpoint'] });
    toast({ title: "Success!" });
  },
});
```

---

## 🚨 Common Mistakes to Avoid

1. **Don't modify these files:**
   - `vite.config.ts` (already configured)
   - `server/vite.ts` (already configured)
   - `drizzle.config.ts` (already configured)

2. **Don't create separate route files** - All routes go in `server/routes.ts`

3. **Don't bypass storage layer** - Always use `storage.methodName()`, never `db.query()` in routes

4. **Don't use `process.env` in frontend** - Use `import.meta.env.VITE_*`

5. **Don't forget Zod validation** - Always validate request bodies with schemas

6. **Don't skip test IDs** - Every interactive element needs `data-testid`

7. **Don't mix mini-app concerns** - Keep each mini-app's code separate

---

## 📚 Existing Mini-Apps Reference

Study these for patterns:

1. **SupportMatch** (`/apps/supportmatch`)
   - Profiles, partnerships, messaging, exclusions, reports
   - Complex matching algorithm
   - Admin moderation tools

2. **SleepStories** (`/apps/sleepstories`)
   - Audio content library
   - Wistia integration
   - Category system

3. **LightHouse** (`/apps/lighthouse`)
   - Dual-role system (seeker/host)
   - Property listings
   - Match requests
   - Conditional dashboard

4. **SocketRelay** (`/apps/socketrelay`)
   - Request/fulfillment system
   - Messaging
   - Profile system

5. **Directory** (`/apps/directory`)
   - Public/private profiles
   - Admin/public views

6. **ChatGroups** (`/apps/chatgroups`)
   - Signal.org group links
   - Public listing of active groups
   - Admin management interface

---

## ✅ Checklist for New Features

- [ ] Schema added to `shared/schema.ts` with proper relations & types
- [ ] Storage methods added to interface & implemented
- [ ] API routes added with Zod validation & error handling
- [ ] **Public endpoints implement anti-scraping protection** (rate limiting, fingerprinting, data obfuscation)
- [ ] Frontend pages created following design guidelines
- [ ] Routes registered in `App.tsx`
- [ ] Sidebar navigation updated
- [ ] Seed script created in `scripts/` for the mini-app
- [ ] Country fields use the shared dropdown and options list
- [ ] External links use the `useExternalLink` hook with confirmation dialog
- [ ] All interactive elements have `data-testid` attributes
- [ ] WCAG AAA compliance verified (contrast, keyboard nav)
- [ ] Loading states implemented
- [ ] Error handling implemented
- [ ] Database schema pushed: `npm run db:push`

---

## 🎯 When in Doubt

1. **Look at existing code** - Study SupportMatch/LightHouse patterns
2. **Read design_guidelines.md** - For all UI/UX decisions
3. **Follow the sequence** - Schema → Storage → Routes → Pages → Navigation
4. **Keep it modular** - Each mini-app is independent
5. **Test as you build** - Use `data-testid` for future testing

---

**This platform serves vulnerable users. Every line of code should prioritize safety, privacy, and dignity.**
